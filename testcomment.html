<!DOCTYPE html>
<html>
<head>
<title>Page Title</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
  
<script src='https://cdnjs.cloudflare.com/ajax/libs/tabletop.js/1.5.1/tabletop.min.js'></script>
<script type='text/javascript'>    
  var publicSpreadsheetUrl = 'https://docs.google.com/spreadsheets/d/1y2pe9-kgELYp8gUHu6fjGOClm2XT1QcBXCufXD4Hjxc/edit?usp=sharing';

  function init() {
    Tabletop.init( { key: publicSpreadsheetUrl,
                     callback: parseSpreadsheet,
                     simpleSheet: true } )
  }

  function parseSpreadsheet(data, tabletop) {
    alert('Successfully processed!');

// Tabletop returns objects as rows, we need to recombine them into arrays of columns
// https://github.com/jsoma/tabletop/issues/170#issuecomment-538659494
// Get the keys
const keys = Object.keys(data[0]);
// Turn them into a list of objects
const mapped = keys.map( function(key) {
    // Get the key's value for each existing object, only keep non-empty ones
    return ({ [key]: data.map( o => o[key] ).filter( value => value ) });
})
// Turn that list into a global object
commentData = Object.assign(...mapped);


    console.log(commentData);

  }

  window.addEventListener('DOMContentLoaded', init)
</script>

<script>
// a helper function to parse template literals from within strings
String.prototype.interpolate = function(params) {
  const names = Object.keys(params);
  const vals = Object.values(params);
  return new Function(...names, `return \`${this}\`;`)(...vals);
}

// a helper function to fix articles that need changing from 'a' to 'an'
function fixArticles(text)
{
  // a function to insert and return a string
  function insert(str, index, value)
  {
    return str.substr(0, index) + value + str.substr(index);
  }
  
  function testVowel(index)
  {
    let match = false;
    let vowels = ["a","e","i","o","u"];
    for (const vowel of vowels) if (text.charAt(index) === vowel) match = true;
    return match;
  }
  
  for (let i = 0; i < text.length; i++)
  {
    let truthTable = []; // for if simplicity
    truthTable[0] = (text.charAt(i-3) === " ");
    truthTable[1] = (text.charAt(i-2) === "a");
    truthTable[2] = (text.charAt(i-1) === " ");
    
    if (truthTable[0] && truthTable[1] && truthTable[2]) if (testVowel(i)) text = insert(text,i-1,"n");
  }
  return text;
}

// a helper function to capitalise first letters after sentence enders (.!?)
function sentenceCase(input, lowercaseBefore) {
    input = ( input === undefined || input === null ) ? '' : input;
    if (lowercaseBefore) { input = input.toLowerCase(); }
    return input.toString().replace( /(^|[\.!?] *)([a-z])/g, function(match, separator, char) {
        return separator + char.toUpperCase();
    });
}
  
  
var name = "Elena";

var skill = "fluency";

function select(...args) { return args[Math.floor(Math.random() * args.length)]; }; 
  
function adj(article = false)
{
  // without a paramenter, just spit out a random adjective from the combination of both arrays
  
  // separate arrays for articles 'a' and 'an'
  var adj_a = ["great","wonderful","fantastic","terrific","brilliant","tremendous","fabulous","magnificant","remarkable"]
  var adj_an = ["outstanding","amazing","awesome","incredible","excellent"]; 
                                                
  // generate a random index array into both arrays
  var index = Math.floor(Math.random() * (adj_a.length + adj_an.length));
                         
  if (article) // prepend either a symbol to let the wrapper function know what to prepend
  {
    if (index >= adj_a.length) return ":" + adj_an[index - adj_a.length];
    else return "." + adj_a[index];
  }
  // article is false, just return the plain adjective
  else if (index >= adj_a.length) return adj_an[index - adj_a.length]; else return adj_a[index];
};

function an_adj()
{
  var res = adj(true);
  if (res.startsWith(":")) res = res.replace(":", "an ");
  if (res.startsWith(".")) res = res.replace(".", "a " );
  return res
}

function personality()
{
  return select("charismatic","bubbly","chatty","creative","communicative","enthusiastic","hard-working","nice","pro-active","thoughtful","likeable","giving","cheerful","convivial","expressive","energetic","enthusiastic","easy-going"); 
};
// watch out! adjectives that need to be fixed with helper function an: expressive, energetic, enthusiastic, easy-going

function optional(arg) { if (Math.random() < 0.5) return arg; else return ""; };

function optionalArray(...args)
{
  return args.filter(args => {if (Math.random() < 0.5) return true; else return false;})
};
 
</script>


</head>
<body>


<button onclick="comment()">Click me</button>

<p id="demo"></p>


<script>
function comment()
{
  // helper function
  function dotOrExclamation()
  {
    if (Math.random() > 0.5) return "!"; else return ".";
  }
  
  var theComment = ""; // the string that will contain the final comment
  var order = []; // the array that contains the structure of the comment

  // determine arrangement of comment
  
 // do we want any combination of week, personal, personal week, either or both?
if (Math.random() > 0.5) order = order.concat(optionalArray("week","personal")); else order = order.concat(optionalArray("personal","week"));
// if nothing, then add "positive" to first position
if (order.length === 0) order.push("positive");
// optional focus
if (Math.random() > 0.5) order.push("focus");
// optional "positive when not in first position
if (order[0] !== "positive") if (Math.random() > 0.5) order.push("positive");
// always add a closer
order.push("closer");

console.log(order);
  
  // OLD VERSION
  /*
  var orderA = ['week','personal','focus','positive','closer'];
  var orderB = ['personal','week','focus','positive','closer'];
  var orderC = ['positive','focus','closer'];
  var orderD = ['week','focus','positive','closer'];
  var orderD = ['personal','focus','positive','closer'];

  order = select(orderA, orderB, orderC, orderD);
  */
  
  // loop through order, selecting a random commentData and adding it to theComment
  for (let i = 0; i < order.length; i++)
  {
    // if week first, we need to add the name first.
    if ((i === 0) && (order[i] === "week")) theComment += "${name} ";

    // if personal first, we need to add the name first.
    if ((i === 0) && (order[i] === "personal")) theComment += "${name} ";

    /////// Main comment adder /////// 

    theComment += commentData[order[i]][Math.floor(Math.random() * commentData[order[i]].length)];

   /////// END Main comment adder /////// 
   
   // if personal and week are going to be neighours we need to add an " and " in between them
    if (((order[i] === "personal") && (order[i+1] === "week")) || ((order[i] === "week") && (order[i+1] === "personal")))  theComment += " and ";
    
    // if personal and week WERE neighours we need to add a full stop after.
    if (((order[i] === "personal") && (order[i-1] === "week")) || ((order[i] === "week") && (order[i-1] === "personal")))  theComment += dotOrExclamation() + " ";

    // after adding to the comment, when we hit "focus" we need some logic to determine which skill to talk about after. for now, just go to "fluency"
    if (order[i] === "focus") theComment += ". " + commentData["fluency"][Math.floor(Math.random() * commentData["fluency"].length)] + ". ";

    // if "positive" is first, we need to add the name after. otherwise, elsewhere in the comment it needs a full stop.
    if ((i === 0) && (order[i] === "positive")) theComment += " ${name}! ";
    else if (order[i] === "positive") theComment += dotOrExclamation() + " ";

    // if "personal" is first and there is no week after, or "week" is first and there is no "personal" after we need to add a full stop and space
    if (((i === 0) && (order[i] === "personal") && (order[i+1] !== "week")) || ((i === 0) && (order[i] === "week") && (order[i+1] !== "personal"))) theComment += dotOrExclamation() + " ";

    // after the closer, we need to add some punctuation
    if (order[i] === "closer") theComment += dotOrExclamation() + " ";

  } // End of compiling comment.

  // parse template literals
  theComment = theComment.interpolate({});
  
  // fix any incorrect articles
  // there shouldn't be! don't use this
  //theComment = fixArticles(theComment);

  // capitalise every first letter after a full stop or exclamation or question mark.
  theComment = sentenceCase(theComment);

  // FINALLY print out results
  document.getElementById("demo").innerHTML = theComment;
}
</script>



</body>
</html>
